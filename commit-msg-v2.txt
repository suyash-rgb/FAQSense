feat: fix knowledge base sync and resolve critical preview errors

This commit addresses several critical blockers identified during the interactive testing of the chatbot management system:

- **Resolved Preview 422 & 500 Errors (Root Cause Fix)**:
    - **Issue**: The frontend was sending a random string (e.g., `conv_session`) for `conversation_id`, while the backend schema and MySQL database were strictly expecting an `integer`. This caused a `pymysql.err.DataError` and internal server crashes.
    - **Fix**: Updated `FAQAskRequest` schema to allow string IDs and implemented a resolution layer in `conversation_service.py` (`get_session_conversation`) to map these session strings to internal database IDs.
    - **Future Action**: A full migration to change the primary key of the `conversations` table from `Integer` to `String/UUID` is planned for more robust session handling.

- **Implemented Knowledge Base Persistence**:
    - **The Issue**: Flow Designer state was lost on page reload.
    - **Fix**: Added a new `GET /chatbots/{id}/data` endpoint to fetch current training data from the server.
    - **Backend Integration**: Implemented `get_chatbot_data` service in Python to read and parse the CSV knowledge base into JSON for the frontend.
    - **Frontend Sync**: Updated `KnowledgeBase.jsx` to fetch and load this data into the Flow Designer on mount.

- **Workflow & UI Polish**:
    - Addressed the strict CSV header requirement by harmonizing both frontend and backend to use singular `Question` and `Answer` headers.
    - Implemented an automatic tab transition: users are now redirected to the **Preview** tab 1 second after a successful upload/save.
    - Resized and centered the **ChatWindow** in the preview container to prevent truncation and improve aesthetics.
    - Enabled `forceOpen={true}` in Preview mode for immediate interaction.

- **Technical Debt & Temporary Changes**:
    - **Headers**: Temporarily hardcoded CSV header validation in `chatbot_service.py` to be singular-only.
    - **Sync Logic**: The current implementation reads from the CSV file for every "data fetch" request; a more efficient database-backed caching layer for visualization state may be considered later.
